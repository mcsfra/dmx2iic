Disassembly Listing for DMX-Dimmer-I2C
Generated From:
D:/GitHub/dimmer-dmx-i2c/dmx2iic/DMX-Dimmer-I2C.X/dist/default/debug/DMX-Dimmer-I2C.X.debug.elf
26.04.2020 21:30:16

---  D:/GitHub/dimmer-dmx-i2c/dmx2iic/DMX-Dimmer-I2C.X/pca9685.c  ---------------------------------------
1:             #include "pca9685.h"
2:             #include "i2c.h"
3:             #include "lookuptable.h"
4:             
5:             
6:             #ifdef PCA_DEBUGMODE
7:             static unsigned char debugState[128];
8:             #endif
9:             
10:            unsigned char pcaGetAddress(unsigned char which)  {
031C  6E0C     MOVWF i, ACCESS
11:                
12:                return (unsigned char)(PCA9685_I2C_BASE_ADDRESS + ( which == 0 ? 0 : 2)); 
031E  500C     MOVF i, W, ACCESS
0320  B4D8     BTFSC STATUS, 2, ACCESS
0322  D004     BRA 0x32C
0324  0E00     MOVLW 0x0
0326  6E0E     MOVWF value, ACCESS
0328  0E02     MOVLW 0x2
032A  D003     BRA 0x332
032C  0E00     MOVLW 0x0
032E  6E0E     MOVWF value, ACCESS
0330  0E00     MOVLW 0x0
0332  6E0D     MOVWF 0xD, ACCESS
0334  500D     MOVF 0xD, W, ACCESS
0336  0F80     ADDLW 0x80
13:            }
0338  0012     RETURN 0
14:            
15:            void pcaInit(unsigned char which)  {
03E0  6E10     MOVWF level, ACCESS
16:              
17:            #ifdef PCA_DEBUGMODE    
18:                unsigned char i; 
19:                for (i = 0; i < 128; i++)  {
20:                    debugState[i] = 0; 
21:                }
22:            #endif    
23:                // Es hat sich gezeigt, dass die 50 Hz a) nichts bringen und b) noch schlimmeres Flackern produzieren. 
24:                // Also nicht verwenden.
25:                // pcaSleep(which);
26:                // pcaSetSpeed(which, 50);
27:                pcaWakeUp(which);
03E2  5010     MOVF level, W, ACCESS
03E4  EC6D     CALL 0x2DA, 0
03E6  F001     NOP
28:                
29:            }
03E8  0012     RETURN 0
30:              
31:            
32:            void pcaSetChannelRaw(unsigned char which, unsigned char channel, unsigned int level)  {
01DE  6E12     MOVWF which, ACCESS
33:                    
34:                i2cStart();
01E0  EC03     CALL 0x406, 0
01E2  F002     NOP
35:                i2cSend(pcaGetAddress(which) );
01E4  5012     MOVF which, W, ACCESS
01E6  EC8E     CALL 0x31C, 0
01E8  F001     NOP
01EA  ECE2     CALL 0x3C4, 0
01EC  F001     NOP
36:                i2cSend(( channel * 4U ) + 0x06U);
01EE  500F     MOVF channel, W, ACCESS
01F0  0D04     MULLW 0x4
01F2  50F3     MOVF PROD, W, ACCESS
01F4  0F06     ADDLW 0x6
01F6  ECE2     CALL 0x3C4, 0
01F8  F001     NOP
37:                i2cSend(0x00);
01FA  0E00     MOVLW 0x0
01FC  ECE2     CALL 0x3C4, 0
01FE  F001     NOP
38:                i2cSend(0x00);
0200  0E00     MOVLW 0x0
0202  ECE2     CALL 0x3C4, 0
0204  F001     NOP
39:                i2cSend((unsigned char)(level & 0xFF));
0206  5010     MOVF level, W, ACCESS
0208  ECE2     CALL 0x3C4, 0
020A  F001     NOP
40:                i2cSend((unsigned char)((level >> 8 ) & 0x0F));
020C  5011     MOVF 0x11, W, ACCESS
020E  0B0F     ANDLW 0xF
0210  ECE2     CALL 0x3C4, 0
0212  F001     NOP
41:                i2cStop();
0214  ECFF     CALL 0x3FE, 0
0216  F001     NOP
42:            }
0218  0012     RETURN 0
43:                 
44:            void pcaSetChannelLin(unsigned char which, unsigned char channel, unsigned char value)   {
45:                    
46:                unsigned int v = value; 
47:                pcaSetChannelRaw(which, channel, v << 4); 
48:            }
49:             
50:            void pcaSetChannelLog(unsigned char which, unsigned char channel, unsigned char value)  {
033A  6E15     MOVWF which, ACCESS
51:                   
52:                pcaSetChannelRaw(which, channel, getLookup(value)); 
033C  C013     MOVFF channel, channel
033E  F00F     NOP
0340  5014     MOVF value, W, ACCESS
0342  EC7E     CALL 0x2FC, 0
0344  F001     NOP
0346  C00C     MOVFF i, level
0348  F010     NOP
034A  C00D     MOVFF 0xD, 0x11
034C  F011     NOP
034E  5015     MOVF which, W, ACCESS
0350  ECEF     CALL 0x1DE, 0
0352  F000     NOP
53:            }
0354  0012     RETURN 0
54:            
55:            void pcaSleep(unsigned char which)    {
56:                
57:                i2cStart();
58:                i2cSend(pcaGetAddress(which) );
59:                i2cSend(0x00);
60:                i2cSend(0x10);
61:                i2cStop();
62:            }
63:            
64:            void pcaWakeUp(unsigned char which)   {
02DA  6E0F     MOVWF channel, ACCESS
65:                    
66:                i2cStart();
02DC  EC03     CALL 0x406, 0
02DE  F002     NOP
67:                i2cSend(pcaGetAddress(which));
02E0  500F     MOVF channel, W, ACCESS
02E2  EC8E     CALL 0x31C, 0
02E4  F001     NOP
02E6  ECE2     CALL 0x3C4, 0
02E8  F001     NOP
68:                i2cSend(0x00);
02EA  0E00     MOVLW 0x0
02EC  ECE2     CALL 0x3C4, 0
02EE  F001     NOP
69:                i2cSend(0x80 | 0x20);
02F0  0EA0     MOVLW 0xA0
02F2  ECE2     CALL 0x3C4, 0
02F4  F001     NOP
70:                i2cStop();
02F6  ECFF     CALL 0x3FE, 0
02F8  F001     NOP
71:            }
02FA  0012     RETURN 0
72:            
73:            void pcaSetSpeed(unsigned char which, unsigned int hertz)   {
74:                    
75:                unsigned long data = (unsigned long)(25000000L / ( 4096L * hertz)) - 1; 
76:                
77:                i2cStart();
78:                i2cSend(pcaGetAddress(which));
79:                i2cSend(0xFE);
80:                i2cSend((unsigned char) data);
81:                i2cStop();
82:            }
83:            
84:            /*
85:             * Testrun
86:             */
87:            
88:            void pcaSweepTest(void)  {
89:                
90:                unsigned char i, j;
91:               
92:                for(;;)   {
93:                    for (j = 0; j < 255; j++ )  {
94:                        for ( i = 0; i < 16; i++)  {        
95:                           pcaSetChannelLog(0,i,j);
96:                        }
97:                    }
98:                }
99:            }    
100:            
101:           
102:           
103:           
104:           
105:           
106:                   
---  D:/GitHub/dimmer-dmx-i2c/dmx2iic/DMX-Dimmer-I2C.X/main.c  ------------------------------------------
1:             #include <xc.h>        /* XC8 General Include File */
2:             
3:             #include "hardware.h"
4:             #include "dmx.h"
5:             #include "i2c.h"
6:             #include "pca9685.h"
7:             #include "setup.h"
8:             #include "channels.h"
9:             
10:            unsigned char errorCounter = 0;
11:            
12:            unsigned char baseAddress; 
13:            
14:            /*
15:             * Pinout
16:             *  
17:             *  1 --  VDD  
18:             *  2 -- 
19:             *  3 -- 
20:             *  4 --  /Reset
21:             *  5 --  DMX Address 16 
22:             *  6 --  DMX Address  8
23:             *  7 --  DMX Address  4
24:             *  8 --  DMX Address 32 
25:             *  9 --  DMX Address 64
26:             * 10 --
27:             * 11 --  I2C - Clock
28:             * 12 --  DMX IN 
29:             * 13 --  I2C - Data
30:             * 14 --  RC2 - DMX State - Framing Error
31:             * 15 --  RC1 - DMX State - No Signal 
32:             * 16 --  RC0 - DMX State - IncomingData > 0
33:             * 17 --   
34:             * 18 --  RA1 - Programming DATA 
35:             * 19 --  RA0 - Programming CLOCK
36:             * 20 --  GND
37:             *  
38:             */
39:            
40:            void main(void)  {
41:             
42:                initHardware();             // I/O Registers
0106  ECAE     CALL 0x15C, 0
0108  F000     NOP
43:                initChannels();             // Internal Data Stuctures
010A  EC29     CALL 0x252, 0
010C  F001     NOP
44:                i2cInit();                  
010E  ECB8     CALL 0x370, 0
0110  F001     NOP
45:                pcaInit(0);                 // Enable PCA #0
0112  0E00     MOVLW 0x0
0114  ECF0     CALL 0x3E0, 0
0116  F001     NOP
46:                pcaInit(1);                 // Enable PCA #1
0118  0E01     MOVLW 0x1
011A  ECF0     CALL 0x3E0, 0
011C  F001     NOP
47:                initDMX();                  // And finally dmx. 
011E  EC57     CALL 0x2AE, 0
0120  F001     NOP
48:              
49:                RCONbits.IPEN = 1;          // Peripheral Interrupts enable 
0122  8ED0     BSF RCON, 7, ACCESS
50:                
51:                /*
52:                 * Hier habe ich ein ToDo. Eigentlich dachte ich, dass ich auf den LoeInte4rrupt reagiere
53:                 * Dennoch müssen wie es scheint BEIDE Bits gesetzt sein. Nanu?
54:                 */   
55:            
56:                INTCONbits.GIEH = 1; 
0124  8EF2     BSF INTCON, 7, ACCESS
57:                INTCONbits.GIEL = 1;
0126  8CF2     BSF INTCON, 6, ACCESS
58:                PEIE = 1; 
0128  8CF2     BSF INTCON, 6, ACCESS
59:                
60:                /*
61:                 *  Initialize connected PCAs
62:                 */
63:                
64:                pcaWakeUp(0);
012A  0E00     MOVLW 0x0
012C  EC6D     CALL 0x2DA, 0
012E  F001     NOP
65:                pcaWakeUp(1);
0130  0E01     MOVLW 0x1
0132  EC6D     CALL 0x2DA, 0
0134  F001     NOP
66:                
67:                for (;;)  {
68:                    
69:                    if ( OERR )  {
0136  A2AB     BTFSS RCSTA, 1, ACCESS
0138  D008     BRA 0x14A
70:                       CREN = 0; 
013A  98AB     BCF RCSTA, 4, ACCESS
71:                       __nop(); __nop(); __nop(); __nop(); __nop();
013C  F000     NOP
013E  F000     NOP
0140  F000     NOP
0142  F000     NOP
0144  F000     NOP
72:                       OERR = 0;
0146  92AB     BCF RCSTA, 1, ACCESS
73:                       CREN = 1; 
0148  88AB     BSF RCSTA, 4, ACCESS
74:                    }
75:                    
76:                    
77:                     // Work
78:                    sendChangedChannels(); 
014A  EC51     CALL 0xA2, 0
014C  F000     NOP
79:            
80:                    // Cable Monitoring         
81:                    decrementDataWatchdog();            // Handle Watchdog for Channeldata within Addressrange > 0
014E  ECC4     CALL 0x388, 0
0150  F001     NOP
82:                    decrementFramingWatchdog();         // Watchdog for detection and reporting of framing errors ( cable copnnection interchanged )
0152  ECCF     CALL 0x39E, 0
0154  F001     NOP
83:                 
84:                    
85:                    if ( decrementSignalWatchdog() == 1 )  {  
0156  ECAB     CALL 0x356, 0
0158  F001     NOP
015A  D7ED     BRA 0x136
86:                    //     SPEN = 0;
87:                    //     RCIE = 0;
88:                    //     initDMX();
89:                    }
90:            #ifdef ADVANCED_POWER_SAVE    
91:                        testChannelLevels();
92:            #endif            
93:                }
94:            }
95:            
96:            
97:            
---  D:/GitHub/dimmer-dmx-i2c/dmx2iic/DMX-Dimmer-I2C.X/lookuptable.c  -----------------------------------
1:             /*
2:              * File:   lookuptable.c
3:              * Author: marcus
4:              *
5:              * Created on 28. Februar 2018, 20:02
6:              */
7:             
8:             #include "lookuptable.h"
9:             
10:            /* Steilere Kurve im unteren bereich
11:            const unsigned int lookup[] = {
12:                    0,    4,    8,   12,   17,   21,   25,   30,   34,   39,   43,   48,   52,   57,   61,   66,
13:                   71,   75,   80,   85,   90,   95,  100,  105,  110,  115,  120,  126,  131,  136,  142,  147,
14:                  152,  158,  164,  169,  175,  180,  186,  192,  198,  204,  210,  216,  222,  228,  234,  241,
15:                  247,  253,  260,  266,  273,  279,  286,  293,  299,  306,  313,  320,  327,  334,  341,  349,
16:                  356,  363,  371,  378,  386,  393,  401,  409,  417,  425,  433,  441,  449,  457,  465,  474,
17:                  482,  490,  499,  508,  516,  525,  534,  543,  552,  561,  571,  580,  589,  599,  608,  618,
18:                  628,  637,  647,  657,  667,  678,  688,  698,  709,  719,  730,  741,  752,  762,  774,  785,
19:                  796,  807,  819,  830,  842,  854,  866,  878,  890,  902,  914,  927,  939,  952,  964,  977,
20:                  990, 1003, 1017, 1030, 1044, 1057, 1071, 1085, 1099, 1113, 1127, 1141, 1156, 1170, 1185, 1200,
21:                 1215, 1230, 1245, 1261, 1276, 1292, 1308, 1324, 1340, 1356, 1373, 1389, 1406, 1423, 1440, 1457,
22:                 1475, 1492, 1510, 1528, 1546, 1564, 1582, 1600, 1619, 1638, 1657, 1676, 1695, 1715, 1735, 1754,
23:                 1774, 1795, 1815, 1836, 1856, 1877, 1899, 1920, 1942, 1963, 1985, 2007, 2030, 2052, 2075, 2098,
24:                 2121, 2144, 2168, 2192, 2216, 2240, 2264, 2289, 2314, 2339, 2364, 2390, 2416, 2442, 2468, 2495,
25:                 2521, 2548, 2576, 2603, 2631, 2659, 2687, 2716, 2744, 2773, 2803, 2832, 2862, 2892, 2923, 2953,
26:                 2984, 3015, 3047, 3079, 3111, 3143, 3176, 3208, 3242, 3275, 3309, 3343, 3378, 3412, 3448, 3483,
27:                 3519, 3555, 3591, 3628, 3665, 3702, 3740, 3778, 3816, 3855, 3894, 3934, 3973, 4014, 4054, 4095
28:            };
29:            */
30:            
31:              const unsigned int lookup[] = {
32:                0,       1,    2,    3,    4,    5,    6,    7,    8,    9,   10,   11,   12,   13,   14,   15,
33:                16,     18,   19,   20,   21,   23,   24,   25,   26,   28,   29,   31,   32,   33,   35,   36,
34:                38,     40,   41,   43,   44,   46,   48,   49,   51,   53,   55,   57,   59,   60,   62,   64,
35:                66,     68,   71,   73,   75,   77,   79,   82,   84,   86,   89,   91,   94,   96,   99,  101,
36:                104,   107,  109,  112,  115,  118,  121,  124,  127,  130,  133,  136,  140,  143,  146,  150,
37:                153,   157,  160,  164,  168,  172,  175,  179,  183,  187,  192,  196,  200,  204,  209,  213,
38:                218,   223,  227,  232,  237,  242,  247,  252,  258,  263,  269,  274,  280,  286,  291,  297,
39:                303,   310,  316,  322,  329,  335,  342,  349,  356,  363,  370,  377,  385,  392,  400,  408,
40:                416,   424,  432,  441,  449,  458,  467,  476,  485,  494,  503,  513,  523,  533,  543,  553,
41:                564,   574,  585,  596,  608,  619,  631,  642,  655,  667,  679,  692,  705,  718,  731,  745,
42:                759,   773,  787,  801,  816,  831,  847,  862,  878,  894,  911,  927,  944,  961,  979,  997,
43:                1015, 1034, 1052, 1072, 1091, 1111, 1131, 1151, 1172, 1194, 1215, 1237, 1259, 1282, 1305, 1329,
44:                1353, 1377, 1402, 1427, 1453, 1479, 1505, 1532, 1560, 1588, 1616, 1645, 1674, 1704, 1735, 1766,
45:                1797, 1829, 1862, 1895, 1929, 1963, 1998, 2034, 2070, 2107, 2144, 2182, 2221, 2260, 2300, 2341,
46:                2382, 2425, 2468, 2511, 2556, 2601, 2647, 2694, 2741, 2790, 2839, 2889, 2940, 2992, 3044, 3098,
47:                3153, 3208, 3265, 3322, 3381, 3440, 3501, 3562, 3625, 3689, 3754, 3820, 3887, 3955, 4024, 4095
48:              };
49:                
50:                
51:            
52:            unsigned int getLookup(unsigned char value)  {
02FC  6E0E     MOVWF value, ACCESS
53:                
54:                return lookup[value];
02FE  500E     MOVF value, W, ACCESS
0300  0D02     MULLW 0x2
0302  0EFF     MOVLW 0xFF
0304  24F3     ADDWF PROD, W, ACCESS
0306  6EF6     MOVWF TBLPTR, ACCESS
0308  0E3B     MOVLW 0x3B
030A  20F4     ADDWFC PRODH, W, ACCESS
030C  6EF7     MOVWF TBLPTRH, ACCESS
030E  0009     TBLRD*+
0310  CFF5     MOVFF TABLAT, i
0312  F00C     NOP
0314  000A     TBLRD*-
0316  CFF5     MOVFF TABLAT, 0xD
0318  F00D     NOP
55:            }
031A  0012     RETURN 0
56:            
57:            
58:            
59:            
60:            
---  D:/GitHub/dimmer-dmx-i2c/dmx2iic/DMX-Dimmer-I2C.X/interrupts.c  ------------------------------------
1:             #include <xc.h>         
2:             #include "dmx.h"
3:             
4:             /* 
5:             ** High-priority service
6:             */
7:             
8:             
9:             /*
10:            void interrupt high_isr(void)  {
11:            }
12:            */
13:            
14:            void high_priority interrupt high_isr(void)  {
0008  8227     BSF btemp, 1, ACCESS
0280  CFD9     MOVFF FSR2, 0x7
15:            
16:                /*
17:                 * DMX- Eingangsdatenstrom
18:                 */
19:                if (PIR1bits.RCIF == 1)  {
0290  AA9E     BTFSS PIR1, 5, ACCESS
20:                    handleDMX();
0294  EC15     CALL 0x2A, 0
21:                    PIR1bits.RCIF = 0;
0298  9A9E     BCF PIR1, 5, ACCESS
22:                }
23:            }
029A  C00A     MOVFF 0xA, PRODH
24:            
25:            
26:            
27:            
28:            /*
29:            ** Low prio Interrupt
30:            */
31:            
32:            void low_priority interrupt low_isr(void)  {
0018  8027     BSF btemp, 0, ACCESS
001A  CFE0     MOVFF BSR, 0xB
001C  F00B     NOP
33:            
34:                /*
35:                 * DMX- Eingangsdatenstrom
36:                 */
37:               // if (PIR1bits.RCIF == 1)  {
38:               //     handleDMX();
39:                //    PIR1bits.RCIF = 0;
40:               // }
41:            }
001E  C00B     MOVFF 0xB, BSR
0020  FFE0     NOP
0022  9027     BCF btemp, 0, ACCESS
0024  0010     RETFIE 0
---  D:/GitHub/dimmer-dmx-i2c/dmx2iic/DMX-Dimmer-I2C.X/i2c.c  -------------------------------------------
1:             #include <xc.h>
2:             #include "i2c.h"
3:             
4:             
5:             unsigned char bI2CTimeout;
6:             
7:             void i2cInit(void)  {
8:                   
9:                 TRISBbits.RB4 = 1; 
0370  8893     BSF TRISB, 4, ACCESS
10:                TRISBbits.RB6 = 1; 
0372  8C93     BSF TRISB, 6, ACCESS
11:               
12:                SSPCON1bits.SSPEN = 1;
0374  8AC6     BSF SSPCON1, 5, ACCESS
13:                SSPADD  = 0x08;   // das stimmt doch nicht, oder? 
0376  0E08     MOVLW 0x8
0378  6EC8     MOVWF SSPADD, ACCESS
14:                SSPCON1 = 0x28;
037A  0E28     MOVLW 0x28
037C  6EC6     MOVWF SSPCON1, ACCESS
15:                SSPSTAT = 0x00;
037E  0E00     MOVLW 0x0
0380  6EC7     MOVWF SSPSTAT, ACCESS
16:                
17:                bI2CTimeout = 0; 
0382  0E00     MOVLW 0x0
0384  6E21     MOVWF bI2CTimeout, ACCESS
18:                
19:            }
0386  0012     RETURN 0
20:            
21:            /*
22:             * Von Microchip gemopst
23:             */
24:            
25:            /*
26:             *  i2c startcondition 
27:             */
28:            void i2cStart()  {
29:            
30:               SSPCON2bits.SEN = 1;      // set start condition and wait  
0406  80C5     BSF SSPCON2, 0, ACCESS
31:               while(SSPCON2bits.SEN)    // until hardware reseets it
32:                   ;
0408  A0C5     BTFSS SSPCON2, 0, ACCESS
040A  0012     RETURN 0
040C  D7FD     BRA 0x408
33:            }
34:            
35:            /*
36:             *  i2c stop.
37:             */
38:            void i2cStop()   {
39:              
40:               SSPCON2bits.PEN = 1;    
03FE  84C5     BSF SSPCON2, 2, ACCESS
41:               while(SSPCON2bits.PEN)  
42:                   ;
0400  A4C5     BTFSS SSPCON2, 2, ACCESS
0402  0012     RETURN 0
0404  D7FD     BRA 0x400
43:            }
44:            
45:            /*
46:             * i2c restart
47:             */
48:            void i2cRestart()   {
49:                
50:               SSPCON2bits.RSEN = 1;    
51:               while(SSPCON2bits.RSEN) 
52:                  ;
53:            }
54:            
55:            /*
56:            Function: I2CAck
57:            Return:
58:            Arguments:
59:            Description: Generates acknowledge for a transfer
60:            */
61:            void i2cAck()  {
62:            
63:               unsigned char timeout = 0xFFU; 
64:                
65:               SSPCON2bits.ACKDT = 0;         // Acknowledge data bit, 0 = ACK 
66:               SSPCON2bits.ACKEN = 1;         // Ack data enabled 
67:               while(SSPCON2bits.ACKEN)   {   // wait for ack data to send on bus 
68:                  if ( timeout-- == 0)  {
69:                      bI2CTimeout = 1; 
70:                      return; 
71:                  }
72:               }
73:            }
74:            
75:            /*
76:            Function: I2CNck
77:            Return:
78:            Arguments:
79:            Description: Generates Not-acknowledge for a transfer
80:            */
81:            void i2cNak()  {
82:                
83:               unsigned char timeout = 0xFFU;  
84:                
85:               SSPCON2bits.ACKDT = 1; // Acknowledge data bit, 1 = NAK 
86:               SSPCON2bits.ACKEN = 1; // Ack data enabled 
87:              
88:               while(SSPCON2bits.ACKEN)   { // wait for ack data to send on bus 
89:                  if ( timeout-- == 0)  {
90:                      bI2CTimeout = 1;
91:                      return; 
92:                  }
93:               }
94:            }
95:            
96:            /*
97:            Function: I2CWait
98:            Return:
99:            Arguments:
100:           Description: wait for transfer to finish
101:           */
102:           void i2cWait()  {
103:           
104:                while ((SSPCON2 == 0x1F ) || ( SSPSTAT == 0x04 ) )
03B2  0E1F     MOVLW 0x1F
03B4  18C5     XORWF SSPCON2, W, ACCESS
03B6  B4D8     BTFSC STATUS, 2, ACCESS
03B8  D7FC     BRA i2cWait
03BA  0E04     MOVLW 0x4
03BC  18C7     XORWF SSPSTAT, W, ACCESS
03BE  A4D8     BTFSS STATUS, 2, ACCESS
03C0  0012     RETURN 0
03C2  D7F7     BRA i2cWait
105:                    ;
106:           }
107:           
108:           /*
109:           Function: I2CSend
110:           Return:
111:           Arguments: dat - 8-bit data to be sent on bus
112:           data can be either address/data byte
113:           Description: Send 8-bit data on I2C bus
114:           */
115:           void i2cSend(unsigned char dat)  {
03C4  6E0C     MOVWF i, ACCESS
116:           
117:              SSPBUF = dat;    // Move data to SSPBUF 
03C6  C00C     MOVFF i, SSPBUF
03C8  FFC9     NOP
118:              while(BF)        // wait till complete data is sent from buffer 
119:                 ; 
03CA  B0C7     BTFSC SSPSTAT, 0, ACCESS
03CC  D7FE     BRA 0x3CA
120:              i2cWait(); 
03CE  ECD9     CALL 0x3B2, 0
03D0  F001     NOP
121:           }
03D2  0012     RETURN 0
122:           
123:           /*
124:           Function: I2CRead
125:           Return: 8-bit data read from I2C bus
126:           Arguments:
127:           Description: read 8-bit data from I2C bus
128:           */
129:           unsigned char i2cRead(void)  {
130:           
131:               unsigned char timeout = 0xFFU; 
132:                                           
133:               SSPCON2bits.RCEN = 1;        //  enable data reception... 
134:               while(!SSPSTATbits.BF)  {    // ...and wait for buffer full 
135:                
136:                   if ( timeout-- == 0)  {  // data should be available within a reasonable time  
137:                       bI2CTimeout = 1;     // if not, set timeout and return
138:                       return 0;            // and return 
139:                   }
140:               }
141:               
142:               unsigned char temp = SSPBUF;    // read buffer 
143:               i2cWait();                       
144:               return temp;                     
145:           }
146:           
---  D:/GitHub/dimmer-dmx-i2c/dmx2iic/DMX-Dimmer-I2C.X/hardware.c  --------------------------------------
1:             #include <xc.h>
2:             #include "hardware.h"
3:             
4:             
5:             
6:             void initHardware(void)  {
7:             
8:               // 8MHz internal OscillatorBlock
9:             
10:              OSCCONbits.IDLEN = 0;
015C  9ED3     BCF OSCCON, 7, ACCESS
11:            
12:              OSCCONbits.IRCF2 = 1;
015E  8CD3     BSF OSCCON, 6, ACCESS
13:              OSCCONbits.IRCF1 = 1;
0160  8AD3     BSF OSCCON, 5, ACCESS
14:              OSCCONbits.IRCF0 = 0;
0162  98D3     BCF OSCCON, 4, ACCESS
15:            
16:              OSCCONbits.SCS1  = 1;
0164  82D3     BSF OSCCON, 1, ACCESS
17:              OSCCONbits.SCS0  = 0;
0166  90D3     BCF OSCCON, 0, ACCESS
18:            
19:              /*
20:              ** I/O
21:              */
22:            
23:              CM1CON0  = 0;
0168  0E00     MOVLW 0x0
016A  6E6D     MOVWF CM1CON0, ACCESS
24:              CM2CON0  = 0;
016C  0E00     MOVLW 0x0
016E  6E6B     MOVWF CM2CON0, ACCESS
25:            
26:              ANSEL   = 0x00;
0170  0E00     MOVLW 0x0
0172  6E7E     MOVWF ANSEL, ACCESS
27:              ANSELH  = 0x00;
0174  0E00     MOVLW 0x0
0176  6E7F     MOVWF ANSELH, ACCESS
28:            
29:              LATA    = 0x00;
0178  0E00     MOVLW 0x0
017A  6E89     MOVWF LATA, ACCESS
30:              PORTA   = 0x00;
017C  0E00     MOVLW 0x0
017E  6E80     MOVWF PORTA, ACCESS
31:              TRISA   = 0b00000011;              
0180  0E03     MOVLW 0x3
0182  6E92     MOVWF TRISA, ACCESS
32:            
33:              PORTB   = 0x00;
0184  0E00     MOVLW 0x0
0186  6E81     MOVWF PORTB, ACCESS
34:              LATB    = 0x00;
0188  0E00     MOVLW 0x0
018A  6E8A     MOVWF LATB, ACCESS
35:              TRISB   = 0b10100111;
018C  0EA7     MOVLW 0xA7
018E  6E93     MOVWF TRISB, ACCESS
36:            
37:              LATC    = 0x00;
0190  0E00     MOVLW 0x0
0192  6E8B     MOVWF LATC, ACCESS
38:              PORTC   = 0x00;
0194  0E00     MOVLW 0x0
0196  6E82     MOVWF PORTC, ACCESS
39:              TRISC   = 0b11111000;  // für DMX-Basisadresse  
0198  0EF8     MOVLW 0xF8
019A  6E94     MOVWF TRISC, ACCESS
40:              
41:                        // 2^0 - RC3 - Pin7
42:                        // 2^1 - RC4 - Pin6
43:                        // 2^2 - RC5 - Pin5
44:                        // 2^3 - RC6 - Pin8
45:                        // 2^4 - RC7 - Pin9
46:            }
019C  0012     RETURN 0
---  D:/GitHub/dimmer-dmx-i2c/dmx2iic/DMX-Dimmer-I2C.X/dmx.c  -------------------------------------------
1:             #include <xc.h>
2:             #include "dmx.h"
3:             #include "setup.h"
4:             #include "channels.h"
5:             
6:             /*
7:             ** States for DMX Statemachine
8:             */ 
9:             #define DMX_NOTSYNCED 0x00
10:            #define DMX_WAITSTART 0x01
11:            #define DMX_PAYLOAD	  0x02
12:             
13:            /*
14:            ** Baudrate
15:            ** Datasheet Page 280
16:            */
17:            
18:            #define MEGAHERTZ 1000000
19:            #define FOSC (8 * MEGAHERTZ)
20:            
21:            
22:            /*'
23:             * Variables for Statemachine
24:             */
25:            
26:            unsigned char dmxState; 
27:            unsigned char currentAdress;
28:            
29:            unsigned char baseAddress; 
30:            unsigned char topAddress; 
31:            
32:            
33:            
34:            /*
35:             * Initialize DMX Hardware and internal statemachine 
36:             * 
37:             * 250000  8N2 
38:             * 
39:             */
40:            void initDMX()  {
41:                
42:                baseAddress       = getDMXBaseAddress(); 
02AE  EC07     CALL 0x40E, 0
02B0  F002     NOP
02B2  6E23     MOVWF baseAddress, ACCESS
43:                topAddress        = baseAddress + MAXCHANNELS;
02B4  5023     MOVF baseAddress, W, ACCESS
02B6  0F20     ADDLW 0x20
02B8  6E22     MOVWF topAddress, ACCESS
44:            
45:                currentAdress     = 0;
02BA  0E00     MOVLW 0x0
02BC  6E24     MOVWF currentAdress, ACCESS
46:                dmxState          = DMX_NOTSYNCED;
02BE  0E00     MOVLW 0x0
02C0  6E25     MOVWF dmxState, ACCESS
47:                
48:                BAUDCONbits.BRG16 = 1;     // Baudratengenerator 8-Bit
02C2  86B8     BSF BAUDCON, 3, ACCESS
49:                BAUDCONbits.CKTXP = 1;     // polaritaet verdrehen
02C4  88B8     BSF BAUDCON, 4, ACCESS
50:                SPBRG1            = 1;     // Baudrate einstellen
02C6  0E01     MOVLW 0x1
02C8  6EAF     MOVWF SPBRG, ACCESS
51:                SPBRGH            = 0;     //
02CA  0E00     MOVLW 0x0
02CC  6EB0     MOVWF SPBRGH, ACCESS
52:            
53:                RCSTA1bits.CREN   = 1;
02CE  88AB     BSF RCSTA, 4, ACCESS
54:                RCSTA1bits.SPEN   = 1;
02D0  8EAB     BSF RCSTA, 7, ACCESS
55:                SYNC   = 0;                 // 2.01 - Review of Datasheet
02D2  98AC     BCF TXSTA, 4, ACCESS
56:             
57:                PIE1bits.RCIE     = 1;
02D4  8A9D     BSF PIE1, 5, ACCESS
58:                IPR1bits.RCIP     = 1;     // HIgh Priority
02D6  8A9F     BSF IPR1, 5, ACCESS
59:            
60:            }
02D8  0012     RETURN 0
61:            
62:            /*
63:             *  DMX Basisadresse von ausen einstellbar
64:             *  Beachten: 
65:             *     * Die PIn reihenfolge ist gemischt.
66:             *     * Eingestellte Adresse mal 4 
67:             */
68:            unsigned char getDMXBaseAddress(void)  {
69:                
70:                return (unsigned char)(PORTC >> 1U) & 0b01111100U;
040E  90D8     BCF STATUS, 0, ACCESS
0410  3082     RRCF PORTC, W, ACCESS
0412  0B7C     ANDLW 0x7C
71:            }
0414  0012     RETURN 0
72:            
73:            /*
74:             * This interrupt sequence is FAAAR too slow.
75:             */
76:            
77:            
78:            void handleDMX()  {
79:                
80:               // unsigned char baseAddress = getDMXBaseAddress();             
81:              // unsigned char eOverflow   = (unsigned char)OERR;             // Read overflow error?
82:                unsigned char eFraming    = (unsigned char)FERR;             // Read framing error
002A  0E00     MOVLW 0x0
002C  B4AB     BTFSC RCSTA, 2, ACCESS
002E  0E01     MOVLW 0x1
0030  6E05     MOVWF eFraming, ACCESS
83:                unsigned char received    = RCREG;                           // Read SerialIn register
0032  CFAE     MOVFF RCREG, received
0034  F006     NOP
84:                    
85:                resetSignalWatchdog();                      // Received data, therefore at least a "signal" is available
0036  ECF5     CALL 0x3EA, 0
0038  F001     NOP
86:               
87:                if ( eFraming == 1)  {                      // Framing Error 
003A  0405     DECF eFraming, W, ACCESS
003C  A4D8     BTFSS STATUS, 2, ACCESS
003E  D00B     BRA 0x56
88:                    
89:                    if ( dmxState == DMX_NOTSYNCED )  {     // expected
0040  5025     MOVF dmxState, W, ACCESS
0042  A4D8     BTFSS STATUS, 2, ACCESS
0044  D005     BRA 0x50
90:                        currentAdress = 0;                  // new receive cycle
0046  0E00     MOVLW 0x0
0048  6E24     MOVWF currentAdress, ACCESS
91:                        dmxState      = DMX_WAITSTART;
004A  0E01     MOVLW 0x1
004C  6E25     MOVWF dmxState, ACCESS
92:                    }
004E  0012     RETURN 0
93:                    else  {
94:                        resetFramingWatchdog();             // This is the case if e.g. d+ and d- are interchanged 
0050  ECEA     CALL 0x3D4, 0
0052  F001     NOP
0054  0012     RETURN 0
95:                    }
96:                    return; 
97:                }
98:            
99:                if ( (dmxState == DMX_WAITSTART) && (received == 0x00) )  {
0056  0425     DECF dmxState, W, ACCESS
0058  A4D8     BTFSS STATUS, 2, ACCESS
005A  D006     BRA 0x68
005C  5006     MOVF received, W, ACCESS
005E  A4D8     BTFSS STATUS, 2, ACCESS
0060  D003     BRA 0x68
100:           
101:                   dmxState = DMX_PAYLOAD;
0062  0E02     MOVLW 0x2
0064  6E25     MOVWF dmxState, ACCESS
0066  0012     RETURN 0
102:                   return;
103:               }
104:           
105:               if ( dmxState == DMX_PAYLOAD)  {
0068  0E02     MOVLW 0x2
006A  1825     XORWF dmxState, W, ACCESS
006C  A4D8     BTFSS STATUS, 2, ACCESS
006E  0012     RETURN 0
106:                 
107:                   if ( (currentAdress >= baseAddress) &&  (currentAdress < topAddress))  {
0070  5023     MOVF baseAddress, W, ACCESS
0072  5C24     SUBWF currentAdress, W, ACCESS
0074  A0D8     BTFSS STATUS, 0, ACCESS
0076  D00E     BRA 0x94
0078  5022     MOVF topAddress, W, ACCESS
007A  5C24     SUBWF currentAdress, W, ACCESS
007C  B0D8     BTFSC STATUS, 0, ACCESS
007E  D00A     BRA 0x94
108:             
109:                       if (received > 0)  {
0080  5006     MOVF received, W, ACCESS
0082  A4D8     BTFSS STATUS, 2, ACCESS
110:                          resetDataWatchdog(); 
0084  ECFA     CALL 0x3F4, 0
0086  F001     NOP
111:                       }
112:                       setChannelLevel((unsigned char)(currentAdress - baseAddress), received); 
0088  C006     MOVFF received, __pcstackCOMRAM
008A  F001     NOP
008C  5023     MOVF baseAddress, W, ACCESS
008E  5C24     SUBWF currentAdress, W, ACCESS
0090  ECCF     CALL 0x19E, 0
0092  F000     NOP
113:                   }
114:                   
115:                   if ( ++currentAdress >= 128)
0094  2A24     INCF currentAdress, F, ACCESS
0096  0E7F     MOVLW 0x7F
0098  6424     CPFSGT currentAdress, ACCESS
009A  0012     RETURN 0
116:                      dmxState = DMX_NOTSYNCED;
009C  0E00     MOVLW 0x0
009E  6E25     MOVWF dmxState, ACCESS
117:               }
118:           }
00A0  0012     RETURN 0
119:           
120:           
121:           /*
122:            * DMX Error Monitoring
123:            * 
124:            *  [[ Editors Note: Diese Methoden sind doch sehr ähnlich; hier wäre eine generifizierung 
125:            *     Denkbar ]]
126:            *
127:            */
128:           
129:           /*
130:            *  Daten vorhanden? 
131:            */
132:           
133:           
134:           volatile unsigned int dataWatchdog = 0; 
135:           
136:           inline void resetDataWatchdog()  {
137:               dataWatchdog = 100; 
03F4  0E00     MOVLW 0x0
03F6  6E1F     MOVWF 0x1F, ACCESS
03F8  0E64     MOVLW 0x64
03FA  6E1E     MOVWF dataWatchdog, ACCESS
138:           }
03FC  0012     RETURN 0
139:           
140:           void decrementDataWatchdog()  {
141:             
142:             //  This codeblock should avoid   
143:             //  if ( LATCbits.LATC2  == 1)   {    // in case of Framing Errrors, data cannot be good. We will override therefore the siganling of ghood data.
144:             //   if (PORTCbits.RC2 == 1 )  {
145:             //       LATCbits.LATC0 = 0; 
146:             //       return;        
147:             //   }
148:               
149:               if ( dataWatchdog > 0)  {
0388  501E     MOVF dataWatchdog, W, ACCESS
038A  101F     IORWF 0x1F, W, ACCESS
038C  B4D8     BTFSC STATUS, 2, ACCESS
038E  D005     BRA 0x39A
150:                   dataWatchdog--; 
0390  061E     DECF dataWatchdog, F, ACCESS
0392  A0D8     BTFSS STATUS, 0, ACCESS
0394  061F     DECF 0x1F, F, ACCESS
151:                   LED_DATAVALID = 1; 
0396  808B     BSF LATC, 0, ACCESS
152:               }
0398  0012     RETURN 0
153:               else   { 
154:                   LED_DATAVALID = 0;
039A  908B     BCF LATC, 0, ACCESS
155:               }    
156:           }
039C  0012     RETURN 0
157:           
158:           /*
159:            * Monitor: Liegt ein serielles Signal an? 
160:            */
161:           
162:           volatile unsigned int signalWatchdog = 0; 
163:           
164:           inline void resetSignalWatchdog()  {
165:           
166:               signalWatchdog = 1000;   // Changed from 1000 to 10000. 
03EA  0E03     MOVLW 0x3
03EC  6E1D     MOVWF 0x1D, ACCESS
03EE  0EE8     MOVLW 0xE8
03F0  6E1C     MOVWF signalWatchdog, ACCESS
167:           }
03F2  0012     RETURN 0
168:           
169:           unsigned char decrementSignalWatchdog()  {
170:               
171:               if ( signalWatchdog > 0)  {
0356  501C     MOVF signalWatchdog, W, ACCESS
0358  101D     IORWF 0x1D, W, ACCESS
035A  B4D8     BTFSC STATUS, 2, ACCESS
035C  D006     BRA 0x36A
172:                   signalWatchdog--; 
035E  061C     DECF signalWatchdog, F, ACCESS
0360  A0D8     BTFSS STATUS, 0, ACCESS
0362  061D     DECF 0x1D, F, ACCESS
173:                   LED_NOSIGNALERROR = 0; 
0364  928B     BCF LATC, 1, ACCESS
174:                   return 0;
0366  0E00     MOVLW 0x0
0368  0012     RETURN 0
175:               }
176:               else   { 
177:                   LED_NOSIGNALERROR = 1;
036A  828B     BSF LATC, 1, ACCESS
178:                   return 1; 
036C  0E01     MOVLW 0x1
179:               }    
180:           }
036E  0012     RETURN 0
181:           
182:           /*
183:            * Framing errors. 
184:            * Framing Errors kommen auch im Normalbetrieb vor ( Sync) 
185:            * Wenn sie gehäuft vorkommen ist das ein Zeichen für Eine Verpolung
186:           
187:             */
188:           
189:           volatile unsigned int framingErrorWatchdog = 0; 
190:           
191:           inline void resetFramingWatchdog()  {
192:               LED_FRAMINGERROR  = 1; 
03D4  848B     BSF LATC, 2, ACCESS
193:               framingErrorWatchdog = 1000; 
03D6  0E03     MOVLW 0x3
03D8  6E1B     MOVWF 0x1B, ACCESS
03DA  0EE8     MOVLW 0xE8
03DC  6E1A     MOVWF framingErrorWatchdog, ACCESS
194:           } 
03DE  0012     RETURN 0
195:           
196:           void decrementFramingWatchdog()  {
197:               
198:               if (framingErrorWatchdog > 0)  {
039E  501A     MOVF framingErrorWatchdog, W, ACCESS
03A0  101B     IORWF 0x1B, W, ACCESS
03A2  B4D8     BTFSC STATUS, 2, ACCESS
03A4  D004     BRA 0x3AE
199:                  framingErrorWatchdog--;
03A6  061A     DECF framingErrorWatchdog, F, ACCESS
03A8  A0D8     BTFSS STATUS, 0, ACCESS
03AA  061B     DECF 0x1B, F, ACCESS
200:               }
03AC  0012     RETURN 0
201:               else  {
202:                   LED_FRAMINGERROR = 0; 
03AE  948B     BCF LATC, 2, ACCESS
203:               }
204:           }
03B0  0012     RETURN 0
205:           
206:           
207:             
208:               
209:           
---  D:/GitHub/dimmer-dmx-i2c/dmx2iic/DMX-Dimmer-I2C.X/channels.c  --------------------------------------
1:             #include <xc.h>
2:             #include "setup.h"
3:             #include "channels.h"
4:             #include "pca9685.h"
5:             #include "lookuptable.h"
6:             
7:             /*
8:              * DMX ./. I2C Converter zum Treiben des PCA9585
9:              * Version 1.0 Februar 2018
10:             */
11:            
12:            volatile CHANNELINFO channels[MAXCHANNELS];
13:            
14:            /*
15:             * Initializing of channeldata
16:             */
17:            void initChannels()  {
18:                
19:                unsigned char i; 
20:                
21:                for (i = 0; i < MAXCHANNELS; i++)  {
0252  0E00     MOVLW 0x0
0254  6E0C     MOVWF i, ACCESS
0276  2A0C     INCF i, F, ACCESS
22:                    channels[i].bChanged = 0;
0256  500C     MOVF i, W, ACCESS
0258  0D02     MULLW 0x2
025A  50F3     MOVF PROD, W, ACCESS
025C  0F60     ADDLW 0x60
025E  6ED9     MOVWF FSR2, ACCESS
0260  6ADA     CLRF FSR2H, ACCESS
0262  0E00     MOVLW 0x0
0264  6EDF     MOVWF INDF2, ACCESS
23:                    channels[i].level    = 0;
0266  500C     MOVF i, W, ACCESS
0268  0D02     MULLW 0x2
026A  50F3     MOVF PROD, W, ACCESS
026C  0F61     ADDLW 0x61
026E  6ED9     MOVWF FSR2, ACCESS
0270  6ADA     CLRF FSR2H, ACCESS
0272  0E00     MOVLW 0x0
0274  6EDF     MOVWF INDF2, ACCESS
0276  2A0C     INCF i, F, ACCESS
0278  0E1F     MOVLW 0x1F
027A  640C     CPFSGT i, ACCESS
027C  D7EC     BRA 0x256
027E  0012     RETURN 0
24:                }
25:            }
26:            
27:            /*
28:             * Sets a channel to a level and marks the channel as changed. 
29:             * This allows to identify chenged channels to reduce traffic on i2c
30:             * 
31:             * [[ Editors Note: Diese Funktion ist in assembler unglaublich geschwätzig. 
32:             * 
33:             *  */
34:            
35:            void setChannelLevel(unsigned char channel, unsigned char level)   {
019E  6E03     MOVWF channel, ACCESS
36:                
37:                if ( channel >= MAXCHANNELS )  {                // Memory safety
01A0  0E1F     MOVLW 0x1F
01A2  6403     CPFSGT channel, ACCESS
01A4  D001     BRA 0x1A8
01A6  0012     RETURN 0
38:                    return;
39:                }
40:                
41:                CHANNELINFO *cp = &channels[channel];
01A8  5003     MOVF channel, W, ACCESS
01AA  0D02     MULLW 0x2
01AC  50F3     MOVF PROD, W, ACCESS
01AE  0F60     ADDLW 0x60
01B0  6E04     MOVWF cp, ACCESS
42:                
43:                  if ( cp -> level != level)  {  
01B2  5004     MOVF cp, W, ACCESS
01B4  6ED9     MOVWF FSR2, ACCESS
01B6  6ADA     CLRF FSR2H, ACCESS
01B8  0E01     MOVLW 0x1
01BA  26D9     ADDWF FSR2, F, ACCESS
01BC  5001     MOVF __pcstackCOMRAM, W, ACCESS
01BE  18DE     XORWF POSTINC2, W, ACCESS
01C0  B4D8     BTFSC STATUS, 2, ACCESS
01C2  0012     RETURN 0
44:                       cp -> level    = level;
01C4  5004     MOVF cp, W, ACCESS
01C6  6ED9     MOVWF FSR2, ACCESS
01C8  6ADA     CLRF FSR2H, ACCESS
01CA  0E01     MOVLW 0x1
01CC  26D9     ADDWF FSR2, F, ACCESS
01CE  C001     MOVFF __pcstackCOMRAM, INDF2
01D0  FFDF     NOP
45:                     cp -> bChanged = 1; 
01D2  5004     MOVF cp, W, ACCESS
01D4  6ED9     MOVWF FSR2, ACCESS
01D6  6ADA     CLRF FSR2H, ACCESS
01D8  0E01     MOVLW 0x1
01DA  6EDF     MOVWF INDF2, ACCESS
46:                }
47:                
48:                
49:              //  if ( channels[channel].level != level)  {  
50:              //      channels[channel].level    = level;
51:             //       channels[channel].bChanged = 1; 
52:              //  }
53:            }
01DC  0012     RETURN 0
54:            
55:            /*
56:             * Transfers all changed channels via i2c.
57:             */
58:            
59:            void sendChangedChannels(void)  {
60:                
61:                unsigned char i; 
62:                unsigned char device ; 
63:                unsigned char channel; 
64:                
65:                for (i = 0; i < MAXCHANNELS; i++ )  {
00A2  0E00     MOVLW 0x0
00A4  6E19     MOVWF i, ACCESS
00FC  2A19     INCF i, F, ACCESS
66:                    
67:                    if ( channels[i].bChanged == 1)  {
00A6  5019     MOVF i, W, ACCESS
00A8  0D02     MULLW 0x2
00AA  50F3     MOVF PROD, W, ACCESS
00AC  0F60     ADDLW 0x60
00AE  6ED9     MOVWF FSR2, ACCESS
00B0  6ADA     CLRF FSR2H, ACCESS
00B2  04DE     DECF POSTINC2, W, ACCESS
00B4  A4D8     BTFSS STATUS, 2, ACCESS
00B6  D022     BRA 0xFC
68:                        channels[i].bChanged = 0; 
00B8  5019     MOVF i, W, ACCESS
00BA  0D02     MULLW 0x2
00BC  50F3     MOVF PROD, W, ACCESS
00BE  0F60     ADDLW 0x60
00C0  6ED9     MOVWF FSR2, ACCESS
00C2  6ADA     CLRF FSR2H, ACCESS
00C4  0E00     MOVLW 0x0
00C6  6EDF     MOVWF INDF2, ACCESS
69:                       
70:                        if ( i > 15)  {
00C8  0E0F     MOVLW 0xF
00CA  6419     CPFSGT i, ACCESS
00CC  D006     BRA 0xDA
71:                           device  = 1;
00CE  0E01     MOVLW 0x1
00D0  6E17     MOVWF device, ACCESS
72:                           channel = i - 16U;  
00D2  5019     MOVF i, W, ACCESS
00D4  0FF0     ADDLW 0xF0
00D6  6E18     MOVWF channel, ACCESS
73:                        }
00D8  D004     BRA 0xE2
74:                        else  {
75:                           device  = 0;
00DA  0E00     MOVLW 0x0
00DC  6E17     MOVWF device, ACCESS
76:                           channel = i;  
00DE  C019     MOVFF i, channel
00E0  F018     NOP
77:                        }
78:                        
79:                        pcaSetChannelLog(device, channel, channels[i].level);
00E2  C018     MOVFF channel, channel
00E4  F013     NOP
00E6  5019     MOVF i, W, ACCESS
00E8  0D02     MULLW 0x2
00EA  50F3     MOVF PROD, W, ACCESS
00EC  0F61     ADDLW 0x61
00EE  6ED9     MOVWF FSR2, ACCESS
00F0  6ADA     CLRF FSR2H, ACCESS
00F2  50DF     MOVF INDF2, W, ACCESS
00F4  6E14     MOVWF value, ACCESS
00F6  5017     MOVF device, W, ACCESS
00F8  EC9D     CALL 0x33A, 0
00FA  F001     NOP
00FC  2A19     INCF i, F, ACCESS
00FE  0E1F     MOVLW 0x1F
0100  6419     CPFSGT i, ACCESS
0102  D7D1     BRA 0xA6
0104  0012     RETURN 0
80:                    }
81:                }
82:            }
83:            
84:            /*
85:             * Testet ob wir den pca in sleep schicken koennen
86:             *  
87:             *  !!! --- !!!
88:             *  Die Verwendung dieser Methode führt zu irritationen. 
89:             *  Es werden weitere kanäle mitgeführt. Beim aufruf von lichtstimmungen fällt das wenig auf, 
90:             *  wenn einzelne kanäle gefadet werden, laufen ander kanäle mit. 
91:             *  Das ist dann der fall wenn als startbedingung alle känäle == 0 sind. 
92:             *  
93:             *  Diese Methode wird also nicht verwendet.
94:             */
95:            
96:            static unsigned char bAllChannelsOff = 1; 
97:            
98:            void testChannelLevels(void)  {
99:                
100:               unsigned char aChannelIsOn = 0; 
101:               unsigned char i; 
102:               
103:               for (i = 0; i < MAXCHANNELS; i++ )  {
104:               
105:                   if ( channels[i].level > 0)  {
106:                       aChannelIsOn = 1; 
107:                       break; 
108:                   }    
109:               }
110:               
111:               if ( bAllChannelsOff == 1 )  {
112:                   
113:                   if (aChannelIsOn == 1)  {
114:                       pcaWakeUp(0);
115:                       pcaWakeUp(1);
116:                       bAllChannelsOff = 0; 
117:                   }
118:               }
119:               else  {
120:                  if (aChannelIsOn == 0)  {
121:                      pcaSleep(0); 
122:                      pcaSleep(1); 
123:                      bAllChannelsOff = 1;
124:                  }  
125:               }
126:           }
127:           
---  C:/Users/mcs-f/AppData/Local/Temp/sa68.s  ----------------------------------------------------------
021A  0E16     MOVLW 0x16
021C  6EF6     MOVWF TBLPTR, ACCESS
021E  0E04     MOVLW 0x4
0220  6EF7     MOVWF TBLPTRH, ACCESS
0222  0E00     MOVLW 0x0
0224  6EF8     MOVWF TBLPTRU, ACCESS
0226  0009     TBLRD*+
0228  CFF5     MOVFF TABLAT, __pdataCOMRAM
022C  EE00     LFSR 0, 0x60
0230  0E40     MOVLW 0x40
0232  6AEE     CLRF POSTINC0, ACCESS
0234  06E8     DECF WREG, F, ACCESS
0236  E1FD     BNZ 0x232
0238  EE00     LFSR 0, 0x1A
023C  0E0C     MOVLW 0xC
023E  6AEE     CLRF POSTINC0, ACCESS
0240  06E8     DECF WREG, F, ACCESS
0242  E1FD     BNZ 0x23E
0244  9027     BCF btemp, 0, ACCESS
0246  9227     BCF btemp, 1, ACCESS
0248  0E00     MOVLW 0x0
024A  6EF8     MOVWF TBLPTRU, ACCESS
024C  0100     MOVLB 0x0
024E  EF83     GOTO 0x106
0018  8027     BSF btemp, 0, ACCESS
0008  8227     BSF btemp, 1, ACCESS
